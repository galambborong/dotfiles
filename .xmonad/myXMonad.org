#+title: My XMonad Configuration
#+author: Peter Keenan / galambborong
#+property: header-args:haskell :tangle xmonad.hs

* A BRIEF OVERVIEW OF THIS CONFIGURATION
** Sources

I've been using XMonad exclusively for a while. My very first set-up took this [[https://wiki.haskell.org/Xmonad/Config_archive][template configuration]] and customised as appropriate, following the documentation. I briefly ran ArcoLinux with [[https://github.com/arcolinux/arcolinux-xmonad-polybar/blob/master/etc/skel/.xmonad/xmonad.hs][their flavour of XMonad]] and liked some elements of their configuration. (On the whole, it was too heavily configured for my liking, though.)

This config brings 'the best of both worlds' together to my taste.   

My initial customisation used XMobar, but I now use Polybar instead.

* IMPORTS

#+begin_src haskell
import qualified Data.Map as M
import Data.Monoid
import System.Exit
import XMonad
import XMonad.Config.Desktop
import XMonad.Hooks.EwmhDesktops
import XMonad.Hooks.ManageDocks
import XMonad.Hooks.ManageHelpers (doCenterFloat, doFullFloat, isDialog, isFullscreen)
import XMonad.Layout.Cross (simpleCross)
import XMonad.Layout.Fullscreen (fullscreenFull)
import XMonad.Layout.Gaps
import XMonad.Layout.MultiToggle
import XMonad.Layout.MultiToggle.Instances
import XMonad.Layout.ResizableTile
import XMonad.Layout.Spacing
import XMonad.Layout.Spiral (spiral)
import XMonad.Layout.ThreeColumns
import qualified XMonad.StackSet as W
import XMonad.Util.Run
import XMonad.Util.SpawnOnce
#+end_src

* VARIABLES

#+begin_src haskell
myTerminal :: String
myTerminal = "st"

myFocusFollowsMouse :: Bool
myFocusFollowsMouse = True

myClickJustFocuses :: Bool
myClickJustFocuses = False

myBorderWidth :: Dimension
myBorderWidth = 2

myModMask :: KeyMask
myModMask = mod4Mask

myBrowser :: String
myBrowser = "brave"

myWorkspaces :: [String]
myWorkspaces = ["1", "2", "3", "4", "5", "6", "7", "8", "9"]

myNormalBorderColor :: String
myNormalBorderColor = "#dddddd"

myFocusedBorderColor :: String
myFocusedBorderColor = "#ff0000"
#+end_src

* KEYBINDINGS
** Glossary

*Notes:* 
1. =mod= is the super key, often called the Windows key.
2. I haven't yet got the fonts and icons issue sorted when spawning an Emacs session from the daemon - something to revisit.

*** Spawn instances 

| Binding           | Result      | Comments                    |
|-------------------+-------------+-----------------------------|
| =mod-shift-enter= | terminal    |                             |
| =mod-b=           | browser     |                             |
| =mod-c=           | codium      |                             |
| =mod-x=           | emacs frame | provided daemon is running  |
| =mod-p=           | dmenu       | pop down, not a full window |
| =mod-f=           | pcmanfm     | add to a variable           |

*** Window and layout bindings

| Binding           | Result                             | Comments          |
|-------------------+------------------------------------+-------------------|
| =mod-shift-c=     | kill current window                |                   |
| =mod-space=       | rotate through layouts             | see *Layouts*     |
| =mod-shift-space= | reset to default layout            | current workspace |
| =mod-n=           | resize windows                     |                   |
| =mod-j=           | move focus to next window          |                   |
| =mod-k=           | move focus to previous window      |                   |
| =mod-m=           | move focus to master window        |                   |
| =mod-enter=       | swap focussed window to master     |                   |
| =mod-shift-j=     | swap focussed window with next     |                   |
| =mod-shift-k=     | swap focussed window with previous |                   |
| =mod-h=           | shrink master area                 |                   |
| =mod-l=           | expand master area                 |                   |
| =mod-t=           | push window back into tiling       |                   |
| =mod-comma=       | rotate windows into master area    |                   |
| =mod-period=      | rotate windows out of master area  |                   |

*** Session bindings

| Binding       | Result         | Comments         |
|---------------+----------------+------------------|
| =mod-shift-q= | quit XMonad    |                  |
| =mod-q=       | restart XMonad | recompiles first |

** Keybindings

#+begin_src haskell
myKeys conf@(XConfig {XMonad.modMask = modm}) =
  M.fromList $
      -- SPAWN INSTANCES
    [ ((modm .|. shiftMask, xK_Return), spawn $ XMonad.terminal conf),
      ((modm, xK_b), spawn myBrowser),
      ((modm, xK_c), spawn "codium"),
      ((modm, xK_x), spawn "emacsclient -c"),
      ((modm, xK_p), spawn "dmenu_run -i -nb '#191919' -nf '#fea63c' -sb '#fea63c' -sf '#191919' -fn 'Mononoki Nerd Font:pixelsize=14'"),
      ((modm, xK_f), spawn "pcmanfm"),

      -- WINDOW AND LAYOUT BINDINGS
      ((modm .|. shiftMask, xK_c), kill),
      ((modm, xK_space), sendMessage NextLayout),
      ((modm .|. shiftMask, xK_space), setLayout $ XMonad.layoutHook conf),
      ((modm, xK_n), refresh),
      ((modm, xK_j), windows W.focusDown),
      ((modm, xK_k), windows W.focusUp),
      ((modm, xK_m), windows W.focusMaster),
      ((modm, xK_Return), windows W.swapMaster),
      ((modm .|. shiftMask, xK_j), windows W.swapDown),
      ((modm .|. shiftMask, xK_k), windows W.swapUp),
      ((modm, xK_h), sendMessage Shrink),
      ((modm, xK_l), sendMessage Expand),
      ((modm, xK_t), withFocused $ windows . W.sink),
      ((modm, xK_comma), sendMessage (IncMasterN 1)),
      ((modm, xK_period), sendMessage (IncMasterN (-1))),

      -- SESSION BINDINGS
      ((modm .|. shiftMask, xK_q), io (exitWith ExitSuccess)),
      ((modm, xK_q), spawn "xmonad --recompile; xmonad --restart")
    ]
      ++
      [ ((m .|. modm, k), windows $ f i)
        | (i, k) <- zip (XMonad.workspaces conf) [xK_1 .. xK_9],
          (f, m) <- [(W.greedyView, 0), (W.shift, shiftMask)]
      ]
      ++
      [ ((m .|. modm, key), screenWorkspace sc >>= flip whenJust (windows . f))
        | (key, sc) <- zip [xK_w, xK_e, xK_r] [0 ..],
          (f, m) <- [(W.view, 0), (W.shift, shiftMask)]
      ]
#+end_src

* MOUSE BINDINGS

#+begin_src haskell
myMouseBindings (XConfig {XMonad.modMask = modm}) =
  M.fromList $
    -- mod-button1, Set the window to floating mode and move by dragging
    [ ( (modm, button1),
        ( \w ->
            focus w >> mouseMoveWindow w
              >> windows W.shiftMaster
        )
      ),
      -- mod-button2, Raise the window to the top of the stack
      ((modm, button2), (\w -> focus w >> windows W.shiftMaster)),
      -- mod-button3, Set the window to floating mode and resize by dragging
      ( (modm, button3),
        ( \w ->
            focus w >> mouseResizeWindow w
              >> windows W.shiftMaster
        )
      )
    ]
#+end_src

* LAYOUTS

You can specify and transform your layouts by modifying these values. If you change layout bindings be sure to use =mod-shift-space= after restarting (with =mod-q=) to reset your layout state to the new defaults, as xmonad preserves your old layout settings by default.

The available layouts. Each layout is separated by =|||=, which denotes layout choice.

#+begin_src haskell
myBaseConfig = desktopConfig
myManageHook =
  composeAll . concat $
    [ [isDialog --> doCenterFloat],
      [className =? c --> doCenterFloat | c <- myCFloats],
      [title =? t --> doFloat | t <- myTFloats],
      [resource =? r --> doFloat | r <- myRFloats],
      [resource =? i --> doIgnore | i <- myIgnores]
    ]
  where
    myCFloats = ["Galculator", "feh", "mpv"]
    myTFloats = ["Downloads", "Save As..."]
    myRFloats = []
    myIgnores = ["desktop_window"]

myLayout = spacingRaw True (Border 0 5 5 5) True (Border 5 5 5 5) True $ avoidStruts $ mkToggle (NBFULL ?? NOBORDERS ?? EOT) $ tiled ||| Mirror tiled ||| spiral (6 / 7) ||| ThreeColMid 1 (3 / 100) (1 / 2) ||| Full
  where
    tiled = Tall nmaster delta tiled_ratio
    nmaster = 1
    delta = 3 / 100
    tiled_ratio = 1 / 2
#+end_src
* EVENT HANDLING, STATUS BARS AND LOGGING
** Event Handling

Defines a custom handler function for X events. The function should return (All True) if the default handler is to be run afterwards. To combine event hooks use =mappend= or =mconcat= from =Data.Monoid=.

#+begin_src haskell
myEventHook = mempty
#+end_src

** Status bars and Logging

Perform an arbitrary action on each internal state change of X event. See =XMonad.Hooks.DynamicLog= extension for examples.

#+begin_src haskell
myLogHook = return ()
#+end_src

* START-UP HOOK

Perform an arbtirary action each time XMonad starts or is restarted with =mod-q=. Used by, e.g., =XMonad.Layout.PerWorkspace= to initialise per-workspace layout choices.

#+begin_src haskell
myStartupHook :: X ()
myStartupHook = do
  spawnOnce "nitrogen --restore &"
  spawnOnce "picom &"
  spawnOnce "~/.config/polybar/launch.sh"
  spawnOnce "xsetroot -cursor_name left_ptr"
  spawnOnce "emacs --daemon"
  spawnOnce "xmodmap ~/.Xmodmap"
#+end_src

* MAIN
** Main initialisation

Entrypoint for XMonad with the defaults

#+begin_src haskell
main = do
  xmonad . ewmh $ docks defaults
#+end_src

** Defaults

A structure containing the configuration settings

#+begin_src haskell
defaults =
  def
    { -- simple stuff
      terminal = myTerminal,
      focusFollowsMouse = myFocusFollowsMouse,
      clickJustFocuses = myClickJustFocuses,
      borderWidth = myBorderWidth,
      modMask = myModMask,
      workspaces = myWorkspaces,
      normalBorderColor = myNormalBorderColor,
      focusedBorderColor = myFocusedBorderColor,
      -- key bindings
      keys = myKeys,
      mouseBindings = myMouseBindings,
      -- hooks, layouts
      layoutHook = gaps [(U, 35), (D, 5), (R, 5), (L, 5)] $ myLayout ||| layoutHook myBaseConfig,
      manageHook = myManageHook,
      handleEventHook = myEventHook,
      logHook = myLogHook,
      startupHook = myStartupHook
    }
#+end_src

